{"title":"Lab: traps 实验记录及 xv6 系统调用","pub_time":1680012420000,"content":"[TOC]\n\n# 实验记录\n\n## RISC-V assembly\n\n使用`make fs.img`命令编译`user/call.c`，之后阅读`user/call.asm`中的汇编代码，并回答下列问题。\n\n> Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?\n\n![](2023-03-27-19-28-00.png)\n\n&emsp;&emsp;汇编地址为`24`的指令`li a2,13`意为将立即数`13`装入寄存器`a2`，而`13`即为我们传递给`printf`的参数之一，另一个参数`f(8)+1`则被编译器优化，直接被计算结果`12`替代（`li a1,12`）。  \n&emsp;&emsp;第一个字符串参数`\"%d %d\\n\"`通过指针传入，从`28`地址开始的两行汇编`auipc a0,0x0; addi a0,a0,1992`将字符串的地址装载到了`a0`寄存器。  \n\n![](2023-03-27-18-28-13.png)  \n![](2023-03-27-18-29-07.png)  \n![](2023-03-27-18-26-41.png)  \n\n> Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)\n\n&emsp;&emsp;正如前文所说，参数`f(8)+1`被编译器优化，直接被计算结果`12`替代，所以`main`函数并没有调用或内联`f`、`g`函数。  \n\n> At what address is the function printf located?\n\n![](2023-03-28-18-22-10.png)\n\n&emsp;&emsp;通过查看生成的注释可知`printf`位于地址`642`，这也可以通过计算验证。  \n\n$$30_{(16)}+1554_{(10)}=642_{(16)}$$\n\n![](2023-03-27-19-28-59.png)  \n\n![](2023-03-27-18-30-47.png)  \n\n\n> What value is in the register ra just after the jalr to printf in main?\n\n&emsp;&emsp;前文图中的`jalr`指令说明“将原`pc+4`的值写入`f[rd]`”和“`rd`默认为`x1`”，其中`x1`实际就是`ra`寄存器。所以通过简单计算可知，`jalr`执行后`ra`的值为`34+4`即`38`，恰好是`jalr`后一条指令的地址。  \n\n![](2023-03-27-18-44-30.png)\n\n> Run the following code.  \n> ```C\n> unsigned int i = 0x00646c72;\n> printf(\"H%x Wo%s\", 57616, &i);\n> ```\n> What is the output? Here's an [ASCII table](https://www.asciitable.com/) that maps bytes to characters.  \n> The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?  \n> Here's a description of [little- and big-endian](http://www.webopedia.com/TERM/b/big_endian.html) and [a more whimsical description](https://www.rfc-editor.org/ien/ien137.txt).\n\n编译后输出：  \n```text\nHe110 World\n```\n\n&emsp;&emsp;`%x`意为输出十六进制数，且字母用小写，而`hex(57616)=0xe110`，所以前半段字符串`H%x`展开为`He110`。  \n&emsp;&emsp;`%s`意为输出字符串（零作为末尾），ASCII 中十六进制的`64`、`6c`、`72`分别为`d`、`l`、`r`字符，在小端序的机器上大小为`0x00646c72`的 32 位整数相当于长度为四的字节数组`{0x72, 0x6c 0x64, 0}`，所以后半段为展开为`World`。  \n\n&emsp;&emsp;若想要在大端序的机器上获得相同的输出，不用改变`57616`，因为大端序和小端序都是内存里的布局，不影响这个数实际的大小；而`0x00646c72`则应该修改为`0x726c6400`，这时其内存布局为`{0x72, 0x6c, 0x64, 0}`。  \n\n[`printf`格式参考](https://cplusplus.com/reference/cstdio/printf/)  \n\n> In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?  \n> ```C\n> printf(\"x=%d y=%d\", 3);\n> ```\n\n&emsp;&emsp;根据之前的参数传递规律以及`printf`代码，计算机会从`a2`寄存器获取与`y=%d`对应的整数，然而我们我们并没有传入第三个参数（`a2`），所以输出是不确定的。  \n\n![](2023-03-27-19-23-49.png)\n\n## Backtrace\n\nGit Commit: [f4b340979b1142850adf2b3868e1ec5104560bae](https://github.com/CYTMWIA/xv6-labs-2022/commit/f4b340979b1142850adf2b3868e1ec5104560bae)  \n\n&emsp;&emsp;这一节实验的重点在于要了解栈上的数据分布。栈上的空间被函数调用划分成了一个个**不定长**的栈帧，每个栈帧都对应一个函数调用，并保存着对应函数的变量。  \n\n![](2023-03-27-19-28-59.png)  \n\n&emsp;&emsp;以之前的`printf`为例，函数开头就将栈指针减少了 96（栈**向下增长**），也就是获取了 96 字节长的栈空间为自己所用。之后，函数将寄存器`ra`和`s0`存入了栈，并给`s0`赋予了新值，而`s0`实际就是**帧指针**（The GCC compiler stores the frame pointer of the currently executing function in the register s0）。  \n\n&emsp;&emsp;所以栈上空间大概如下图。  \n\n![](2023-03-28-18-49-15.png)\n\n&emsp;&emsp;最终的`backtrace`实现如下。  \n\n```C\nvoid\nbacktrace(void)\n{\n  uint64 fp = r_fp();\n  uint64 pg = PGROUNDDOWN(fp);\n  while (PGROUNDDOWN(fp) == pg) // Same page\n  {\n    printf(\"%p\\n\", *((uint64*)(fp-8)));\n    fp = *((uint64*)(fp-16));\n  }\n}\n```\n\n&emsp;&emsp;值得注意的是合法帧指针的判定方法，随着我们的回溯，帧指针必然是越来越大的（栈向下增长），当我们回溯到第一个函数调用（也就是最后一个`s0/fp`）时，我们怎么才能判定这就是最后的`fp`呢？不幸的是，我没有在网上查找到 GCC 对第一个帧指针的处理方法。但实验的提示给出了答案，利用 xv6 只为栈分配了**一个 page** 的特性（A useful fact is that the memory allocated for each kernel stack consists of a single page-aligned page）。  \n\n## Alarm\n\nGit Commit: [57c9e49ffd5745cc765d6bef43c311111e3a3de8](https://github.com/CYTMWIA/xv6-labs-2022/commit/57c9e49ffd5745cc765d6bef43c311111e3a3de8)  \nGit Commit: [42c2b65b4cada126ad801d9460aa051ddd37dce7](https://github.com/CYTMWIA/xv6-labs-2022/commit/42c2b65b4cada126ad801d9460aa051ddd37dce7)  \n\n&emsp;&emsp;建议提前阅读下方的 *xv6 系统调用*后再来阅读这一节实验。  \n\n&emsp;&emsp;为了实现实验要求的软件定时器，我们需要在`proc`结构体中添加几个变量记录我们的定时器信息，包括**回调函数**、**定时间隔**、**下一次触发时间**（或定时起点，总之需要能确定触发时间），以及用于保存`trapframe`的另一个 **`alarm_frame`**。  \n```C\nvoid (*alarm_handler)();\nuint alarm_interval;\nuint alarm_next;\nstruct trapframe *alarm_frame;\n```\n\n&emsp;&emsp;xv6 作为一个分时操作系统，会定时地不断在进程之间轮转 CPU，所以存在变量（`ticks`）作为“时钟”也是非常正常的。创建计时器时，我使用`ticks`与用户提供的`interval`来计算下一次触发时间，之后对比时间只需单纯的比较就好，不需要任何重新计算。  \n```C\nuint64\nsys_sigalarm(void)\n{\n  int interval;\n  argint(0, &interval);\n  uint64 handler;\n  argaddr(1, &handler);\n  if (interval<0 || handler<0)\n    return -1;\n\n  struct proc *p = myproc();\n  p->alarm_interval = interval;\n  p->alarm_next = ticks+p->alarm_interval;\n  p->alarm_handler = (void (*)())handler;\n  return 0;\n}\n```\n\n&emsp;&emsp;在处理 trap 中判断是否为定时器中断，并检测定时器是否超时，若定时器超时，则将进程的`epc`寄存器修改为回调函数地址。\n```C\nif(which_dev == 2) {\n  do {\n    if (!(p->alarm_interval > 0)) // Alarm enabled\n      break;\n    if (!(p->alarm_frame == 0)) // No running handler\n      break;\n    if (p->alarm_next <= ticks) {\n      p->alarm_next += p->alarm_interval;\n      p->alarm_frame = (struct trapframe *)kalloc();\n      *(p->alarm_frame) = *(p->trapframe);\n      p->trapframe->epc = (uint64)p->alarm_handler;\n    }\n  } while (0);\n}\n```\n\n&emsp;&emsp;为了从回调函数返回到原本的用户程序，我直接使用之前保存的`alarm_frame`覆盖`trapframe`，并释放`alarm_frame`表示回调函数执行完成。同时为了保证`a0`不变，我把`trapframe`中的`a0`作为返回值返回。  \n```C\nuint64\nsys_sigreturn(void)\n{\n  struct proc *p = myproc();\n  if (p->alarm_frame) {\n    *(p->trapframe) = *(p->alarm_frame);\n    kfree((void*)p->alarm_frame);\n    p->alarm_frame = 0;\n  }\n  return p->trapframe->a0;\n}\n```\n\n&emsp;&emsp;这个实验我写了两版，第一版在`proc`创建了 6 个新变量，对比现在的 4 个，多出来的两个是状态变量，用于表示定时器是否启用、回调进程是否处于运行……写完后我感觉状态管理有些复杂于是上网看别人的做法，发现普遍都是 4 或 5 个变量，因为状态可以用已有变量的特殊值来表示，例如`interval`为零表示禁用定时器。用特殊值表示状态不仅减少了变量数量，代码也简单了，因为状态和值是“统一”的。  \n\n参考：[XV6学习（6）Lab: traps](https://www.cnblogs.com/weijunji/p/14338466.html)  \n\n## 实验结束\n\n![](2023-03-28-19-20-05.png)\n\n# xv6 系统调用\n\n## `trap`和`interrupt`的区别\n\n&emsp;&emsp;如果你学过单片机或嵌入式课程的话，可能就分不清`trap`（陷阱）和`interrupt`（中断），因为从 CPU 看来这些好像都是中断呀？ ~~（我就分不太清楚）~~ 所以我先在这放一个链接和一张图（来自CSAPP），希望能帮助你区分两者。  \n\n[What is the difference between Trap and Interrupt?](https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt)  \n![](2023-03-28-19-36-45.png)  \n\n&emsp;&emsp;对于我来说，`interrupt`更倾向于外部硬件，而`trap`则倾向内部。  \n\n## RISC-V 异常\n\n&emsp;&emsp;要了解 xv6 系统调用，首先要知道 RISC-V 如何处理异常，因为 xv6 是通过`ecall`指令调用系统函数（`user/usys.pl`）的，而`ecall`指令会引发 RISC-V 进行异常处理（异常不一定是坏事，只是异于通常的情况）。\n\n![](2023-03-28-19-51-48.png)  \n\n**RISC-V 异常处理流程**（翻译自 *xv6 book*）  \n\n1. 如果是设备中断且`SIE`为零，则不进行下面的步骤\n2. 通过清空`sstatus`中`SIE`位关闭中断\n3. 复制`pc`到`sepc`\n4. 保存当前模式到`sstatus`中的`SPP`位\n5. 将`scause`设置为中断类型\n6. 设置模式为 S 模式\n7. 将`stvec`复制到`pc`\n8. 从`pc`开始执行\n\n图为寄存器的用途说明，S 模式寄存器与其在 M 模式下的版本**功能相同或接近**。  \n![](2023-03-28-19-55-38.png)  \n\n## xv6 处理 trap\n\n&emsp;&emsp;在 RISC-V 硬件完成上方的处理流程之后，就轮到 xv6 了。若发生异常时系统处于用户空间，则跳到`uservec`（`kernel/trampoline.S`）；若系统处于内核空间，则交由`kernelvec`（`kernel/kernelvec.S`）进行处理。  \n&emsp;&emsp;那么，CPU 该怎么知道自己下一步应该调用`uservec`还是`kernelvec`呢？答案是不知道，因为 CPU 只是将`pc`改为`stvec`中的值，然后机械地往下执行指令而已。  \n&emsp;&emsp;xv6 在切换到内核空间时会设置`stvec`通往`kernelvec`；而切换到用户空间时则将`stvec`指向`uservec`。此外，系统启动时属于内核空间，会初始化`stvec`为`kernelvec`。  \n&emsp;&emsp;之后的处理流程建议看书（*xv6 book*），因为书中还有不少细节我无法在此逐一呈现。\n\nxv6 处理 trap 流程图\n![](2023-03-28-20-37-53.png)  \n\n## `uservec`和`kernelvec`\n\n&emsp;&emsp;既然不写流程了，那我就说说我对`uservec`和`kernelvec`的理解。  \n\n&emsp;&emsp;`uservec`和`kernelvec`是功能非常接近的两个函数，都是保存进程的上下文（主要是各种寄存器），但它们的实现却截然不同。`uservec`将上下文保存在了单独的`trapframe`中，而`kernelvec`则直接在栈上开辟了一块空间。  \n\n![](2023-03-28-20-51-47.png)  \n\n&emsp;&emsp;如果说`kernelvec`是因为没有`trapframe`可用所以使用了栈空间，那为什么`uservec`不使用栈空间呢，这样不是更方便吗？因为不用再单独管理`trapframe`了。  \n&emsp;&emsp;假设`uservec`也使用栈空间，那么一切看起来都很正常，直到……我们需要系统调用的返回值！而系统返回值是通过修改寄存器`a0`实现的，之前通过`trapframe`可以让内核程序很方便地修改`a0`寄存器，但使用栈空间的话，要定位用户空间栈上的`a0`寄存器保存地址非常麻烦且容易出错。  \n&emsp;&emsp;现在看来，`kernelvec`使用栈空间再正常不过了，实现简单，而且内核程序也不用进行系统调用（直接调用原始函数即可）。  \n&emsp;&emsp;以上，都是我个人的理解，不保证正确。  \n\n## 新进程如何切换到用户空间\n\n&emsp;&emsp;为什么要单独设置一个切换到用户空间的函数`usertrapret`？  \n&emsp;&emsp;因为不仅是处理 trap 结束后要回到用户空间，创建进程时新进程也需要切换到用户空间。  \n\n新进程切换到用户空间的链条如下：\n\n- 新进程通过`fork`或`userinit`（系统第一个进程）创建，过程中会调用`allocproc`\n- `allocproc`将`p->context.ra`设置为`forkret`\n- `forkret`调用`usertrapret`\n- `usertrapret`设置`stap`、`stvec`等寄存器，即切换到用户空间\n\n&emsp;&emsp;其中`ra`是RISC-V中的返回寄存器，即`ret`指令回到的地址，具体执行起来还涉及调度相关的知识。~~（有空再说~~\n\n"}