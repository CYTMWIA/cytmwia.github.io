{"title":"Lab: system calls","pub_time":1678780800000,"content":"[TOC]\n\n## 实验说明\n\n&emsp;&emsp;这是 MIT 课程 [6.1810: Operating System Engineering](https://pdos.csail.mit.edu/6.828/2022/schedule.html) 的第二个实验 [Lab: system calls](https://pdos.csail.mit.edu/6.828/2022/labs/syscall.html)。  \n&emsp;&emsp;第一个实验 [Lab: Xv6 and Unix utilities](https://pdos.csail.mit.edu/6.828/2022/labs/util.html) 感觉比较简单，而且没什么可扩展的，所以就没有为其写博客。\n\n实验环境：Debian 11 虚拟机\n\n## Using gdb\n\n&emsp;&emsp;按照实验说明使用命令`make qemu-gdb`启动 GDB 调试。\n\n![](2023-03-13-17-16-33.png)\n\n&emsp;&emsp;通过观察输出得知，我们需要在新终端中启动 GDB。  \n\n注：  \n需要在实验目录下启动，以便让 GDB 自动加载目录下的`.gdbinit`。  \n此外，注意观察 GDB 输出，可能会提示关闭了自动加载的功能，需要手动编辑配置文件以启动。  \n\n![](2023-03-13-17-19-01.png)\n\n&emsp;&emsp;可在新终端启动 GDB 后，出现报错`Undefined item: \"riscv:rv64\".`，看来默认的 GDB 并不支持 RISC-V 架构。  \n&emsp;&emsp;课程的 [GDB 说明](https://pdos.csail.mit.edu/6.828/2022/labs/gdb.html)中使用的是`riscv64-unknown-elf-gdb`，然而我这并没有。但课程说明下方提到可以使用`gdb-multiarch`代替，而我这确实也有这个软件。  \n\n![](2023-03-13-17-28-13.png)\n\n> Looking at the backtrace output, which function called syscall? \n\n&emsp;&emsp;使用`b syscall`在`syscall`函数入口处打断点；`c`表示继续运行（启动 GDB 后程序并没有运行，而是暂停在了入口）。  \n&emsp;&emsp;在系统运行到`syscall`并因为断点停止之后，我们可以使用`backtrace`回溯函数调用。\n\n![](2023-03-13-17-39-06.png)\n![](2023-03-13-17-47-40.png)\n\n&emsp;&emsp;现在我们可以回答实验提出的问题了，是`usertrap`调用了`syscall`。\n\n> What is the value of p->trapframe->a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)\n\n&emsp;&emsp;不断输入`n`运行一行代码，直到代码执行到 137 行之后，通过`p /x p->trapframe->a7`我们了解到`p->trapframe->a7` 的值为 7，即`SYS_exec`，这可以从源文件`kernel/syscall.c`和`kernel/syscall.h`得知。\n\n![](2023-03-13-17-56-46.png)\n![](2023-03-13-18-01-00.png)\n\n> What was the previous mode that the CPU was in? \n\n&emsp;&emsp;`sstatus` 是 RISC-V 中的寄存器，用于记录 supervisor 模式下的状态，其中有个字段 SPP，表示进入 supervisor 模式之前的权限模式，若是 0 则表示之前是 user 模式。  \n&emsp;&emsp;通过`p /t $sstatus`得知 SPP 字段为 0，即之前为 user 模式。  \n\n关于 RISC-V 的资料：  \n[RISC-V privileged instructions](https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf)  \n[The RISC-V Reader: An Open Architecture Atlas](http://riscvbook.com/)（有中文）  \n\n![](2023-03-13-18-09-14.png)\n![](2023-03-13-18-26-06.png)\n\n> Write down the assembly instruction the kernel is panicing at. Which register corresponds to the varialable num? \n\n&emsp;&emsp;按照实验说明修改源代码，使系统在启动时崩溃。  \n\n![](2023-03-13-18-31-37.png)\n\n&emsp;&emsp;重新编译并启动 GDB，还是将断点打在`syscall`，通过`layout asm`进入汇编视图，不断使用`ni`执行下一条汇编语句，直到 panic。  \n\n![](2023-03-13-19-49-29.png)\n\n&emsp;&emsp;由汇编视图可知，程序停在了`lw a3,0`，其中`a3`就是变量`num`。\n\n> Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above? (See description of scause in [RISC-V privileged instructions](https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf))\n\n&emsp;&emsp;在 xv6 中，不论是用户还是内核，对内存读写都需要经过页表转换。  \n&emsp;&emsp;`lw a3,0`的意思是从`0`地址读取四个字节并写入`a3`，然而`0`地址并没有映射到物理内存空间，自然就无法读取了，系统也因此 panic。\n\n![](2023-03-13-20-52-20.png)\n![](2023-03-13-20-13-05.png)\n\n&emsp;&emsp;在 RISC-V 中，有许多异常相关的寄存器（如下图），其中`mcause`就指明了异常的类型。而 RISC-V 的 supervisor 模式对比 machine 模式，有许多名字相同的寄存器（只是将第一个字母由 m 变为 s），功能也基本相同。\n\n![](2023-03-13-19-58-10.png)\n![](2023-03-13-20-06-34.png)\n\n&emsp;&emsp;通过查看`sepc`和`scause`寄存器的值，我们不仅知道发生异常的指令地址是`0x80001ff2`，还知道异常种类是`Load page fault`。\n\n![](2023-03-13-20-11-06.png)\n![](2023-03-13-20-05-28.png)\n\n> What is the name of the binary that was running when the kernel paniced? What is its process id (pid)?\n\n![](2023-03-13-20-15-25.png)\n\n## System call tracing\n\nGit Commit: [db0d0eb98b68a83a118d1b1cc0b1592e43266ab9](https://github.com/CYTMWIA/xv6-labs-2022/commit/db0d0eb98b68a83a118d1b1cc0b1592e43266ab9)  \n\n&emsp;&emsp;感觉这部分没啥好说的……顺着实验的 Hints 就可以完成了。  \n\n&emsp;&emsp;虽然我想写写系统调用的具体过程……但我对此的理解还不清楚，感觉很模糊……  \n\n## Sysinfo\n\nGit Commit: [e4496bc29343319c7b986e7125341a9dac558d57](https://github.com/CYTMWIA/xv6-labs-2022/commit/e4496bc29343319c7b986e7125341a9dac558d57)  \n\n### 内存\n\n&emsp;&emsp;在 xv6 中，系统是以页为单位分配内存的（详见[`kernel/kalloc.c`](https://github.com/CYTMWIA/xv6-labs-2022/blob/2f5b6ccf5456b792d4f1939f33faaa36f25fc576/kernel/kalloc.c)），每页的大小是`PGSIZE`。具体实现时，xv6 使用链表将所有空闲页连接了起来，每当分配内存时即从链表拿去一个节点并删除，释放内存则是将之前拿走的节点重新放回到链表当中。  \n&emsp;&emsp;所以，通过遍历链表并计数即可得知当前空闲内存的大小。\n\n```C\nuint64\nfreemem(void)\n{\n  uint free_count = 0;\n  struct run *r;\n  acquire(&kmem.lock);\n  r = kmem.freelist;\n  while (r) {\n    free_count++;\n    r = r->next;\n  }\n  release(&kmem.lock);\n  return PGSIZE*free_count;\n}\n```\n\n&emsp;&emsp;在阅读内存相关代码时，我发现 xv6 使用了下面两个很有意思的宏。\n\n```C\n#define PGSIZE 4096 // bytes per page\n#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))\n#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))\n```\n\n&emsp;&emsp;`PGROUNDUP`用于计算不小于`sz`但离其最近的`PGSIZE`倍数，`PGROUNDDOWN`类似但是不大于`sz`。例如`PGROUNDUP(10000)`的值是 12288，恰好是 4096 的 3 倍；`PGROUNDDOWN(10000)`则是 8192，即 4096 的 2 倍。  \n\n&emsp;&emsp;因为`PGROUNDDOWN`看起来比较简单，所以我们先研究它，看看它是如何实现功能的？  \n&emsp;&emsp;因为 4096 稍微有点大，我们先假设`PGSIZE`是 16，那么 16 的倍数在二进制上有什么特点吗？\n\n```txt\n16*1 = 0b0010000\n16*2 = 0b0100000\n16*3 = 0b0110000\n16*4 = 0b1000000\n```\n\n&emsp;&emsp;仔细观察，发现 16 的倍数在第 5 位数之后是顺序递增的，即`001`、`010`、`011`、`100`……而低 4 位始终为 0，那么我们可以归纳出：任何低 4 位为 0 的二进制数都是 16 的倍数。  \n&emsp;&emsp;这样看来，`PGROUNDDOWN`就很好理解了，通过将低位（`PGSIZE`中的 1 作为分界点）二进制置 0，最后结果自然是`PGSIZE`的倍数，而且大小当然不会超过`sz`。  \n&emsp;&emsp;那么`PGROUNDUP`呢？我们可以将其看作是`PGROUNDDOWN(sz+PGSIZE-1)`，即加上不超过`sz`的最大数，这样既保证了最终结果不会“跳过”某个倍数，又不会使最终结果小于`sz`。  \n\n&emsp;&emsp;以上讨论的前提是`PGSIZE`是 2 的某个整数次方。\n\n### 进程\n\n&emsp;&emsp;在 xv6 中，每个进程都对应了一个`proc`结构体（声明于[`kernel/proc.h`](https://github.com/CYTMWIA/xv6-labs-2022/blob/2f5b6ccf5456b792d4f1939f33faaa36f25fc576/kernel/proc.h#L85)），其中保存了这个进程的各种状态信息，包括 id、页表、打开的文件等。而内核通过一个大小为`NPROC`的`proc`结构体数组来管理所有进程。  \n&emsp;&emsp;通过遍历`proc`数组内的进程，并查询进程的`state`是否为`UNUSED`，即可得知当前系统中共有多少个进程。\n\n```C\nuint\nnproc(void)\n{\n  uint count = 0;\n  for(struct proc *p = proc; p < &proc[NPROC]; p++) {\n    acquire(&p->lock);\n    count += p->state != UNUSED;\n    release(&p->lock);\n  }\n  return count;\n}\n```\n\n## 最后\n\n![](2023-03-14-12-41-38.png)\n\n&emsp;&emsp;虽然完成了实验，但仍感觉有很多细节不太清楚，希望我在后续的实验中能逐渐明白一切。  \n\n&emsp;&emsp;另外说一句，感觉终端下的 GDB 用起来意外地感觉还不错？我之前一直以为很难用来着……  \n"}