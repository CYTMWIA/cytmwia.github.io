{"title":"CSAPP Bomb Lab 记录","pub_time":1676368384000,"content":"[TOC]\n\n## 实验说明\n\n实验网址：  \n[http://csapp.cs.cmu.edu/3e/labs.html](http://csapp.cs.cmu.edu/3e/labs.html)  \n（\"Self-Study Handout\"无需账号即可下载实验内容）  \n\n**Bomb Lab [Updated 1/12/16]**\n\n> A \"binary bomb\" is a program provided to students as an object code file. When run, it prompts the user to type in 6 different strings. If any of these is incorrect, the bomb \"explodes,\" printing an error message and logging the event on a grading server. Students must \"defuse\" their own unique bomb by disassembling and reverse engineering the program to determine what the 6 strings should be. The lab teaches students to understand assembly language, and also forces them to learn how to use a debugger. It's also great fun. A legendary lab among the CMU undergrads. \n\n> 分析二进制的可执行文件，输入正确密码以“拆弹”。\n\n![solved](20230214-bomb-solved.png)  \n\n实验环境：Arch Linux x86_64  \n分析工具：[Cutter](https://github.com/rizinorg/cutter)、[edb-debugger](https://github.com/eteran/edb-debugger)  \n\n## main\n\n![main](20230214-bomb-main.png)\n&emsp;&emsp;`main`的结构比较简单，除去上边处理输入文件的部分，剩下的就是我们要破解的密码，看起来有 6 个 phase 需要我们输入。\n\n## phase_1\n\n![phase_1](20230214-bomb-phase1.png)  \n&emsp;&emsp;非常简单，只有一个`strings_not_equal`函数在检查输入，我们只需输入与目标字符串相同的字符串即可。  \n\n**phase_1** `Border relations with Canada have never been better.`\n\n## phase_2\n\n![phase_2](20230214-bomb-phase2.png)  \n\n&emsp;&emsp;难度略有上升。这段代码进行了如下操作/检查：\n\n1. 调用`read_six_numbers`从我们输入的字符串读取了 6 个数字。\n2. 检查第一个数字是否为 1\n3. 循环检查数组，后一个数是否为前一个数的 2 倍 \n\n**phase_2** `1 2 4 8 16 32`\n\n## phase_3\n\n![phase_3](20230214-bomb-phase3.png)  \n\n1. 调用`__isoc99_sscanf`读取了两个整数（下图为`0x40522cf`处的字符串，即`format`参数）\n   ![0x4025cf](20230214-bomb-phase3-0x4025cf.png)\n2. 利用第一个数与`switch`赋予`iVar1`特定值，并将 0～7 以外的数“引爆”\n3. 对比第二个数与`iVar1`是否相同\n\n**phase_3** `0 207`、`1 311`、`2 707`、`3 256`、`4 389`、`5 206`、`6 682`、`7 327`\n\n## phase_4\n\n![phase_4](20230214-bomb-phase4.png)  \n\n1. 与上一个 phase 相同的`__isoc99_sscanf`，依旧是读取了两个整数\n2. 确保第一个数小于等于 0xe（即 14）\n3. 将第一个数作为第一个参数，调用`func4`\n4. 检查`func4`返回值与第二个数是否为 0\n\n![func4](20230214-bomb-phase4-func4.png)\n\n&emsp;&emsp;看起来`func4`是个递归函数……不太好分析……翻译成 Python 暴力求解吧，因为我们已经知道参数的情况了。  \n\n```python\ndef func4(a1,a2,a3):\n    v1 = None\n    v2 = int((a3-a2)//2+a2)\n    if a1<v2:\n        v1 = func4(a1, a2, v2-1)\n        v1 = v1*2\n    else:\n        v1 = 0\n        if v2<a1:\n            v2 = func4(a1,v2+1,a3)\n            v1 = v2*2+1\n    return v1\n\nfor i in range(16):\n    try:\n        print(i, func4(i, 0 , 14))\n    except RecursionError:\n        print(i, \"RecursionError\")\n```\n\n**phase_4** `0 0`、`1 0`、`3 0`、`7 0`\n\n## phase_5\n\n![phase_5](20230214-bomb-phase5.png)  \n\n1. 检查输入字符串的长度是否为 6\n2. 对字符串内的每一个字符：取字符编码低四位作为索引，从另一字符串选择新字符  \n   将新字符们组成新字符串\n3. 检查新字符串是否与`\"flyers\"`相同\n\n&emsp;&emsp;想要正向找到字符串并不简单，所以我们反向从`\"flyers\"`出发，找到`\"flyers\"`中字符在另一字符串中的索引，并为其补充高四位，组成我们的输入字符串。\n\n```python\ns = \"maduiersnfotvbylSo you think\"[:16]\nfor c in \"flyers\":\n    ci = s.index(c)\n    print(chr((0b0100<<4)|ci), end=\"\")\nprint()\n```\n\n&emsp;&emsp;显然，这道题答案有很多，因为字符编码的高四位并不参与索引。\n\n**phase_5** `IONEFG`\n\n## phase_6\n\n&emsp;&emsp;这道题难度骤升，是我耗费时间最久的题目，昨晚一直看到了凌晨……因为代码很长，而且指针绕来绕去……最后还是靠网上的参考和慢慢看汇编图解决了问题。  \n\n![phase_6-overall](20230214-bomb-phase6-overall.png)  \n\n&emsp;&emsp;上边是整体的汇编图，按功能大致可以分为 5 个部分。  \n\n![phase_6-part1](20230214-bomb-phase6-part1.png)  \n\n&emsp;&emsp;这是第一部分，有以下功能：  \n\n1. 读取六个数字\n2. 确保每个数字都小于或等于 6\n3. 确保每个数字各不相同\n\n![phase_6-part2](20230214-bomb-phase6-part2.png)  \n\n&emsp;&emsp;第二部分，功能比较简单，通过`f(x)=7-x`转换我们输入的 6 个数字。\n\n![phase_6-part3](20230214-bomb-phase6-part3.png)  \n\n&emsp;&emsp;第三部分，将我们的数字根据数值转换成了一个个指针\n\n![phase_6-0x6032d0](20230214-bomb-phase6-0x6032d0.png)  \n\nAddress  |Value(dword)| |Raw Input\n---------|----------|---|----\n0x6032d0 | 0x00014c | 1 | 6\n0x6032d8 | 0x6032e0 |   |  \n0x6032e0 | 0x0000a8 | 2 | 5\n0x6032e8 | 0x6032f0 |   |  \n0x6032f0 | 0x00039c | 3 | 4\n0x6032f8 | 0x603300 |   |  \n0x603300 | 0x0002b3 | 4 | 3\n0x603308 | 0x603310 |   |  \n0x603310 | 0x0001dd | 5 | 2\n0x603318 | 0x603320 |   |  \n0x603320 | 0x0001bb | 6 | 1\n\n&emsp;&emsp;例如我们输入的数字是 4，那么转换后就会变成 0x6032f0。  \n&emsp;&emsp;另外，我们可以注意到，0x6032d0 部分是类似**链表**的数据结构，一个单元内包含有一个值与一个地址，而地址又指向了另一个结构相同的单元。\n\n![phase_6-part4](20230214-bomb-phase6-part4.png)  \n\n&emsp;&emsp;第四部分，修改链表的 next 指针，使节点顺序与我们输入的数字顺序相同。例如我们输入了`5 6`，那么 0x6032e8 地址的值就会被修改成 0x6032d0。  \n\n![phase_6-part5](20230214-bomb-phase6-part5.png)  \n\n&emsp;&emsp;第五部分，检查链表是否为降序（当前节点大于或等于下一节点）。  \n\n**phase_6** `4 3 2 1 6 5`\n\n## phase_secret\n\n&emsp;&emsp;然而事情并没有结束……符号表里有个`secret_phase`，通过查找引用可以发现它在`phase_defused`里被调用。\n\n![phase_defused](20230214-bomb-phase7-defused.png)  \n\n&emsp;&emsp;为了触发`secret_phase`，我们需要往 0x603870 地址输入两个数字并附带字符串`\"DrEvil\"`。  \n&emsp;&emsp;通过动态调试，我们可以发现 0x603870 其实就是我们 phase_4 输入字符串所存储的地址。 \n\n![0x603870](20230214-bomb-phase7-0x603870.png)  \n\n![phase_7](20230214-bomb-phase7.png)  \n\n&emsp;&emsp;`secret_phase`主要做了两件事，一是读取输入并转为整数类型且保证小于或等于 1001；二是调用`fun7`并确保返回值为 2。  \n&emsp;&emsp;另外，我们注意到 0x6030f0 被直接作为参数传入了`fun7`。通过对 0x6030f0 附近内存数据的观察我们猜测这是树的数据结构。  \n\n![0x6030f0](20230214-bomb-phase7-0x6030f0.png)  \n\n![fun7](20230214-bomb-phase7-fun7.png)  \n\n&emsp;&emsp;虽然`fun7`是个递归函数，但由于对`arg1`（0x6030f0）是树有比较充分的把握，所以分析起来还是比较轻松的。  \n&emsp;&emsp;我们想让函数返回 2，所以递归最里层的函数应该返回 1，然后到次里层后 *2 即可。通过对照 0x6030f0 的树和每次函数调用对`arg2`产生的约束，我们可以得知`arg2`应该是 0x16（即 22）。\n\n**phase_4** `0 0 DrEvil`  \n**phase_secret** `22`  \n"}