{"title":"COW 实验记录暨 VS Code 调试使用说明","pub_time":1683030600000,"content":"# Copy-on-Write 介绍\n\n最近我重新把之前的操作系统实验捡了起来，然而迎面撞来的就是 Copy-on-Write（以下简称 COW）实验，COW 的思想非常简单“仅在真正需要写入时才分配内存”。  \n\n例如我们经常将`fork()`与`exec()`放在一起使用，然而在没有 COW 的系统中这一行为会造成极大的浪费，因为`fork()`而**完整复制**的内存实际并没有使用多少就被`exec()`用新内容覆盖了。如果系统有 COW 功能的话，`fork()`并不会复制原进程的内存，而是对其进行引用（只读），在需要写入时再让系统分配一块与原进程内容相同的内存（可读写）。  \n\n虽说 COW 的思想非常简单，但实现起来却不太容易，非常容易遗漏各种细节，从我写下第一行代码到测试全通过，整整经历了四五天（作为对比，之前的实验都是一两天）。  \n\n# VS Code 与 GDB\n\n在开始实现 COW 之前，我想先写下 VS Code 与 GDB 的调试使用说明，方便自己日后查阅。  \n\n在实现 COW 的过程中，常常会发生一些匪夷所思的现象，观察终端输出也完全不知道系统究竟处于什么状态，这时 GDB 就派上用场了，然而我并不想直接使用 GDB 的 TUI 界面（不想记忆我一年到头都用不到几次的 GDB 命令），所以我决定使用 VS Code 的调试功能来配合实验提供的`qemu-gdb`。  \n\n这一节文章旨在正确配置 VS Code 的调试功能和任务功能，并不涉及具体的调试教程或技巧。同时为了避免重复写下别人已经完善的说明，我只列出了相关文档的链接以及我的一点总结。  \n\nVS Code 关于 C/C++ 调试的相关文档：\n\n1. [Debugging](https://code.visualstudio.com/docs/editor/debugging)\n2. [Debug C++ in Visual Studio Code](https://code.visualstudio.com/docs/cpp/cpp-debug)\n3. [Configure C/C++ debugging](https://code.visualstudio.com/docs/cpp/launch-json-reference)\n\n为了使用 VS Code 的调试功能，需要安装对应语言扩展并编写`launch.json`文件。对于 C/C++ 来说，我们需要安装 [C++ extension for VS Code](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)，然后根据项目编写`launch.json`即可（参照链接 3）  \n但现在每次调试都需要自己手动构建项目，非常烦人，我想按下 F5 就直接构建项目并进入调试查看运行效果！所幸，VS Code 也提供了这部分功能，我们可以在`launch.json`中使用`preLaunchTask`让 VS Code 在进入调试前自动运行构建任务。  \n\nVS Code 关于 Task 的相关文档：\n\n1. [Tasks](https://code.visualstudio.com/docs/editor/tasks)\n2. [Schema for `tasks.json`](https://code.visualstudio.com/docs/editor/tasks-appendix)\n\n## 调试 xv6\n\nxv6 提供的命令`make qemu-gdb`在构建完成后会直接启动调试服务器，并没有结束返回，所以我们需要设置`isBackground`字段，此外我们还需配置`beginsPattern`，作为构建成功的标志让 VS Code 启动调试，具体构建任务配置如下：  \n\n```json\n{\n    \"label\": \"qemu-gdb\",\n    \"type\": \"shell\",\n    \"command\": \"make qemu-gdb\",\n    \"isBackground\": true,\n    \"problemMatcher\": {\n        \"pattern\": {\"regexp\": \"\"},\n        \"background\": {\n            \"beginsPattern\": \"Now run 'gdb' in another window.\",\n            \"endsPattern\": \".\"\n        }\n    }\n}\n```\n\n以下是我的调试配置：  \n\n```json\n{\n    \"name\": \"(gdb) 启动\",\n    \"type\": \"cppdbg\",\n    \"request\": \"launch\",\n    \"program\": \"${workspaceFolder}/kernel/kernel\",\n    \"cwd\": \"${workspaceFolder}\",\n    \"MIMode\": \"gdb\",\n    \"miDebuggerServerAddress\": \"127.0.0.1:26000\",\n    \"miDebuggerPath\": \"/usr/bin/gdb-multiarch\",\n    \"preLaunchTask\": \"qemu-gdb\"\n}\n```\n\n已知问题：  \n\n- 无法调试 user 内的代码\n- 需要将`.gdbinit.tmpl-riscv`内的`target remote ...`一行注释（`@REM ...`）或删除，否则 VS Code 调试器无法连接\n\n# Copy-on-Write 实现\n\nGit Commit [6f5ca6f6da8eeceb30787943e8cb6d5f8bc249c8](https://github.com/CYTMWIA/xv6-labs-2022/commit/6f5ca6f6da8eeceb30787943e8cb6d5f8bc249c8)  \n\n作为实现 COW 的第一步，我们要先想一个问题，COW 需要使用怎样的数据结构，才能实现多进程对同一块物理内存的引用，并在需要写入时分配内存。  \n\n我们需要保存每块内存所对应的进程吗？不用，我们的需求并不要求追溯到每一个使用该内存的进程，所以我们只需维护一个计数变量就好了（**引用计数**），每当有一个进程使用该内存时计数就加一，进程释放或触发 COW 时减一。  \n\n前面我们提到了“每块内存”，那么一块应该是多大呢？综合考虑效率与实现的容易程度，Page 大小的内存块应该不错，这也是`kalloc()`一次分配内存的大小。  \n\n决定了引用计数和块的大小之后，我们还需考虑具体该使用哪种数据结构来保存/维护计数，Map、List 或是别的什么？  \n但在选择具体数据结构之前，我们先看看数据的规模，`kalloc.c`中的`end`指针指向了内核代码结束的地方，即可分配内存的起点，但我们没法在编译前确定其值，所以我们使用`KERNBASE`代替，通过计算`(PHYSTOP-KERNBASE)/PGSIZE`可知我们最多需要维护 32768 个引用计数，而 xv6 最大进程数量`NPROC`为 64，每个引用计数只需一个字节即可。  \n所以，我选择使用数组来存储引用计数，因为简单。  \n\n以下即引用计数的具体实现代码：\n\n![](2023-05-02-19-23-57.png)  \n\n接下来，让我们考虑计数的“出入口”，进程进行内存申请或释放时都需要调用特定的函数，那么应该在哪些函数中放置我们引用计数呢？所有可分配内存的“出口”`kalloc()`就不错。  \n\n关于计数的“出入口”我要多说一些，其实 COW 我写了两个实现，但第一个失败了。它并不在`kalloc()`处进行计数，而是在`mappages()`处，虽然通过了`cowtest`，但没有通过`usertests`，因为发生了内存泄漏，本该被释放的内存不知所踪。直到最后我也没找到泄漏的地方，以至于我重写了实验，并按照实验的 hints 在`kalloc()`处进行计数。  \n事后再回忆，在`mappages()`处进行计数属实不是个好注意，因为`mappages()`不仅服务于可分配内存，还服务于其他内存地址，计数时需要对此进行判断；`mappages()`附近也没有现成的锁可用，而不用锁的话则难以保证多线程间的正确性，可能这边一个线程刚释放了内存而另个线程恰好又引用了……  \n\n下面是`kalloc()`和`kfree()`对引用计数的处理。  \n\n![](2023-05-02-19-59-18.png)  \n![](2023-05-02-19-58-01.png)  \n\n你可能已经发现，我的`kalloc()`只实现了计数的初始化，`fork()`产生的新进程需要使用下面的函数`kalloc_ref`来引用原内存。  \n\n![](2023-05-02-20-02-13.png)  \n\n在基础的引用计数完成之后，我们修改`uvmcopy()`以便让`fork()`产生的新进程引用父进程的内存。  \n\n![](2023-05-02-20-16-32.png)  \n\n其中，`PTE_RSW1`是 PTE 项中的保留位，是 RISC-V 硬件留给软件（操作系统）使用的，硬件会无视其值。  \n（下图来自[《RISC-V 手册》](http://riscvbook.com/chinese/)）  \n\n![](2023-05-02-20-27-31.png)  \n\n接下来，我们需要在`usertrap()`和`copyout()`实现在写入时使用新内存。  \n`usertrap()`中我们需要捕获`Write page fault`异常，并根据情况申请新内存或杀死进程。  \n`copyout()`则需要检测目标内存是否合法被多个进程引用，也要根据情况申请新内存或返回错误码。  \n对于相似的需求，自然是通过函数来实现了，然后在需要的地方调用即可。  \n\n![](2023-05-02-20-19-16.png)  \n\n至此，Copy-on-Write 功能已经可用了。  \n\n![](2023-05-02-16-57-36.png)\n"}